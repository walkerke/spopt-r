# Generated by extendr: Do not edit by hand

# nolint start

#
# This file was created with the following call:
#   .Call("wrap__make_spopt_wrappers", use_symbols = TRUE, package_name = "spopt")

#' @usage NULL
#' @useDynLib spopt, .registration = TRUE
NULL

#' Compute Euclidean distance matrix between two sets of points
#'
#' @param x1 X coordinates of first set of points
#' @param y1 Y coordinates of first set of points
#' @param x2 X coordinates of second set of points
#' @param y2 Y coordinates of second set of points
#' @return Distance matrix (n1 x n2)
#' @export
rust_distance_matrix_euclidean <- function(x1, y1, x2, y2) .Call(wrap__rust_distance_matrix_euclidean, x1, y1, x2, y2)

#' Compute Manhattan distance matrix between two sets of points
#'
#' @param x1 X coordinates of first set of points
#' @param y1 Y coordinates of first set of points
#' @param x2 X coordinates of second set of points
#' @param y2 Y coordinates of second set of points
#' @return Distance matrix (n1 x n2)
#' @export
rust_distance_matrix_manhattan <- function(x1, y1, x2, y2) .Call(wrap__rust_distance_matrix_manhattan, x1, y1, x2, y2)

#' Compute minimum spanning tree from adjacency matrix
#'
#' @param i Row indices (0-based) of adjacency matrix non-zero entries
#' @param j Column indices (0-based) of adjacency matrix non-zero entries
#' @param weights Edge weights (distances/dissimilarities)
#' @param n Number of nodes
#' @return List with MST edges (from, to, weight)
#' @export
rust_mst <- function(i, j, weights, n) .Call(wrap__rust_mst, i, j, weights, n)

#' Check if a graph is connected
#'
#' @param i Row indices of adjacency matrix
#' @param j Column indices of adjacency matrix
#' @param n Number of nodes
#' @return TRUE if connected, FALSE otherwise
#' @export
rust_is_connected <- function(i, j, n) .Call(wrap__rust_is_connected, i, j, n)

#' Find connected components
#'
#' @param i Row indices of adjacency matrix
#' @param j Column indices of adjacency matrix
#' @param n Number of nodes
#' @return Vector of component labels (0-based)
#' @export
rust_connected_components <- function(i, j, n) .Call(wrap__rust_connected_components, i, j, n)

#' Solve SKATER regionalization
#'
#' @param attrs Attribute matrix (n x p)
#' @param adj_i Row indices of adjacency
#' @param adj_j Column indices of adjacency
#' @param n_regions Number of regions to create
#' @param floor_var Optional floor variable values
#' @param floor_value Minimum floor value per region
#' @param seed Random seed
#' @return Vector of region labels (1-based)
#' @export
rust_skater <- function(attrs, adj_i, adj_j, n_regions, floor_var, floor_value, seed) .Call(wrap__rust_skater, attrs, adj_i, adj_j, n_regions, floor_var, floor_value, seed)

#' Solve AZP regionalization problem
#'
#' Automatic Zoning Procedure with basic, tabu, and SA variants.
#'
#' @param attrs Attribute matrix (n x p)
#' @param n_regions Number of regions to create
#' @param adj_i Row indices of adjacency (0-based)
#' @param adj_j Column indices of adjacency (0-based)
#' @param method "basic", "tabu", or "sa"
#' @param max_iterations Maximum iterations
#' @param tabu_length Tabu list length (for tabu method)
#' @param cooling_rate SA cooling rate (for sa method)
#' @param initial_temperature SA initial temperature (for sa method)
#' @param seed Random seed
#' @return List with labels, n_regions, objective
#' @export
rust_azp <- function(attrs, n_regions, adj_i, adj_j, method, max_iterations, tabu_length, cooling_rate, initial_temperature, seed) .Call(wrap__rust_azp, attrs, n_regions, adj_i, adj_j, method, max_iterations, tabu_length, cooling_rate, initial_temperature, seed)

#' Solve SPENC regionalization problem
#'
#' Spatially-encouraged spectral clustering.
#'
#' @param attrs Attribute matrix (n x p)
#' @param n_regions Number of regions to create
#' @param adj_i Row indices of adjacency (0-based)
#' @param adj_j Column indices of adjacency (0-based)
#' @param gamma RBF kernel parameter
#' @param seed Random seed
#' @return List with labels, n_regions, objective
#' @export
rust_spenc <- function(attrs, n_regions, adj_i, adj_j, gamma, seed) .Call(wrap__rust_spenc, attrs, n_regions, adj_i, adj_j, gamma, seed)

#' Solve spatially-constrained Ward clustering
#'
#' @param attrs Attribute matrix (n x p)
#' @param n_regions Number of regions to create
#' @param adj_i Row indices of adjacency (0-based)
#' @param adj_j Column indices of adjacency (0-based)
#' @return List with labels, n_regions, objective
#' @export
rust_ward_constrained <- function(attrs, n_regions, adj_i, adj_j) .Call(wrap__rust_ward_constrained, attrs, n_regions, adj_i, adj_j)

#' Solve Max-P regionalization problem
#'
#' Maximize the number of regions such that each region satisfies a minimum
#' threshold constraint on a spatial extensive attribute.
#'
#' @param attrs Attribute matrix (n x p) for computing within-region dissimilarity
#' @param threshold_var Values of the threshold variable (e.g., population)
#' @param threshold Minimum sum required per region
#' @param adj_i Row indices of adjacency (0-based)
#' @param adj_j Column indices of adjacency (0-based)
#' @param n_iterations Number of construction phase iterations
#' @param n_sa_iterations Number of simulated annealing iterations
#' @param cooling_rate SA cooling rate (e.g., 0.99)
#' @param tabu_length Tabu list length for SA
#' @param seed Random seed
#' @param centroids_x X coordinates of unit centroids (for compactness)
#' @param centroids_y Y coordinates of unit centroids (for compactness)
#' @param compact Whether to optimize for compactness
#' @param compact_weight Weight for compactness vs dissimilarity (0-1)
#' @return List with labels (1-based), n_regions, objective, and compactness
#' @export
rust_max_p <- function(attrs, threshold_var, threshold, adj_i, adj_j, n_iterations, n_sa_iterations, cooling_rate, tabu_length, seed, centroids_x, centroids_y, compact, compact_weight) .Call(wrap__rust_max_p, attrs, threshold_var, threshold, adj_i, adj_j, n_iterations, n_sa_iterations, cooling_rate, tabu_length, seed, centroids_x, centroids_y, compact, compact_weight)

#' Solve P-Median facility location problem
#'
#' @param cost_matrix Cost/distance matrix (demand x facilities)
#' @param weights Demand weights
#' @param n_facilities Number of facilities to locate (p)
#' @return List with selected facilities and assignments
#' @export
rust_p_median <- function(cost_matrix, weights, n_facilities) .Call(wrap__rust_p_median, cost_matrix, weights, n_facilities)

#' Solve LSCP (Location Set Covering Problem)
#'
#' @param cost_matrix Cost/distance matrix (demand x facilities)
#' @param service_radius Maximum service distance
#' @return List with selected facilities and coverage
#' @export
rust_lscp <- function(cost_matrix, service_radius) .Call(wrap__rust_lscp, cost_matrix, service_radius)

#' Solve MCLP (Maximum Coverage Location Problem)
#'
#' @param cost_matrix Cost/distance matrix (demand x facilities)
#' @param weights Demand weights
#' @param service_radius Maximum service distance
#' @param n_facilities Number of facilities to locate
#' @return List with selected facilities and coverage
#' @export
rust_mclp <- function(cost_matrix, weights, service_radius, n_facilities) .Call(wrap__rust_mclp, cost_matrix, weights, service_radius, n_facilities)

#' Solve P-Center facility location problem
#'
#' @param cost_matrix Cost/distance matrix (demand x facilities)
#' @param n_facilities Number of facilities to locate
#' @param method Algorithm method: "binary_search" (default) or "mip"
#' @return List with selected facilities, assignments, and max distance
#' @export
rust_p_center <- function(cost_matrix, n_facilities, method) .Call(wrap__rust_p_center, cost_matrix, n_facilities, method)

#' Solve P-Dispersion facility location problem
#'
#' @param distance_matrix Distance matrix between facilities
#' @param n_facilities Number of facilities to select
#' @return List with selected facilities and min distance
#' @export
rust_p_dispersion <- function(distance_matrix, n_facilities) .Call(wrap__rust_p_dispersion, distance_matrix, n_facilities)

#' Solve FRLM using greedy heuristic
#'
#' @param n_candidates Number of candidate facility locations
#' @param path_candidates Flat array of candidate indices for each path
#' @param path_offsets Start index for each path in path_candidates
#' @param path_distances Distances to each candidate along paths
#' @param flow_volumes Volume of each flow
#' @param vehicle_range Maximum vehicle range
#' @param n_facilities Number of facilities to place
#' @return List with selected facilities and coverage info
#' @export
rust_frlm_greedy <- function(n_candidates, path_candidates, path_offsets, path_distances, flow_volumes, vehicle_range, n_facilities) .Call(wrap__rust_frlm_greedy, n_candidates, path_candidates, path_offsets, path_distances, flow_volumes, vehicle_range, n_facilities)

#' Solve Capacitated Facility Location Problem (CFLP)
#'
#' Minimize weighted distance subject to facility capacity constraints.
#' Supports fixed number of facilities or facility opening costs.
#'
#' @param cost_matrix Cost/distance matrix (demand x facilities)
#' @param weights Demand weights
#' @param capacities Capacity of each facility
#' @param n_facilities Number of facilities to locate (0 if using facility costs)
#' @param facility_costs Optional fixed cost to open each facility
#' @return List with selected facilities, assignments, utilizations
#' @export
rust_cflp <- function(cost_matrix, weights, capacities, n_facilities, facility_costs) .Call(wrap__rust_cflp, cost_matrix, weights, capacities, n_facilities, facility_costs)

#' Compute Huff Model probabilities
#'
#' Computes probability surface based on distance decay and attractiveness.
#' Formula: P_ij = (A_j × D_ij^β) / Σ_k(A_k × D_ik^β)
#'
#' @param cost_matrix Cost/distance matrix (demand x stores)
#' @param attractiveness Attractiveness values for each store (pre-computed with exponents)
#' @param distance_exponent Distance decay exponent (typically negative, e.g., -1.5)
#' @param sales_potential Optional sales potential for each demand point
#' @return List with probabilities, market shares, expected sales
#' @export
rust_huff <- function(cost_matrix, attractiveness, distance_exponent, sales_potential) .Call(wrap__rust_huff, cost_matrix, attractiveness, distance_exponent, sales_potential)


# nolint end

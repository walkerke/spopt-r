% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/region_max_p.R
\name{max_p_regions}
\alias{max_p_regions}
\title{Max-P Regions}
\usage{
max_p_regions(
  data,
  attrs = NULL,
  threshold_var,
  threshold,
  weights = "queen",
  bridge_islands = FALSE,
  compact = FALSE,
  compact_weight = 0.5,
  n_iterations = 100L,
  n_sa_iterations = 100L,
  cooling_rate = 0.99,
  tabu_length = 10L,
  scale = TRUE,
  seed = NULL,
  verbose = FALSE
)
}
\arguments{
\item{data}{An sf object with polygon or point geometries.}

\item{attrs}{Character vector of column names to use for computing
within-region dissimilarity (e.g., \code{c("var1", "var2")}). If NULL,
uses all numeric columns.}

\item{threshold_var}{Character. Name of the column containing the threshold
variable (e.g., population, income). Each region must have a sum of this
variable >= \code{threshold}.}

\item{threshold}{Numeric. Minimum sum of \code{threshold_var} required per region.}

\item{weights}{Spatial weights specification. Can be:
\itemize{
\item \code{"queen"} (default): Polygons sharing any boundary point are neighbors
\item \code{"rook"}: Polygons sharing an edge are neighbors
\item An \code{nb} object from spdep or created with \code{\link[=sp_weights]{sp_weights()}}
\item A list for other weight types: \code{list(type = "knn", k = 6)} for
k-nearest neighbors, or \code{list(type = "distance", d = 5000)} for
distance-based weights
}
KNN weights guarantee connectivity (no islands), which can be useful
for datasets with disconnected polygons.}

\item{bridge_islands}{Logical. If TRUE, automatically connect disconnected
components (e.g., islands) using nearest-neighbor edges. If FALSE (default),
the function will error when the spatial weights graph is disconnected.
This is useful for datasets like LA County with Catalina Islands, or
archipelago data where physical adjacency doesn't exist but regionalization
is still desired.}

\item{compact}{Logical. If TRUE, optimize for region compactness in addition
to attribute homogeneity. Compact regions have more regular shapes, which
is useful for sales territories, patrol areas, and electoral districts.
Default is FALSE.}

\item{compact_weight}{Numeric between 0 and 1. Weight for compactness vs
attribute homogeneity when \code{compact = TRUE}. Higher values prioritize
compact shapes over attribute similarity. Default is 0.5.}

\item{n_iterations}{Integer. Number of construction phase iterations (default 100).
Higher values explore more random starting solutions.}

\item{n_sa_iterations}{Integer. Number of simulated annealing iterations (default 100).
Set to 0 to skip the SA refinement phase.}

\item{cooling_rate}{Numeric. SA cooling rate between 0 and 1 (default 0.99).
Smaller values cool faster, larger values allow more exploration.}

\item{tabu_length}{Integer. Length of tabu list for SA phase (default 10).}

\item{scale}{Logical. If TRUE (default), standardize attributes before
computing dissimilarity.}

\item{seed}{Optional integer for reproducibility.}

\item{verbose}{Logical. Print progress messages.}
}
\value{
An sf object with a \code{.region} column containing region assignments.
Metadata is stored in the "spopt" attribute, including:
\itemize{
\item algorithm: "max_p"
\item n_regions: Number of regions created (the "p" in max-p)
\item objective: Total within-region sum of squared deviations
\item threshold_var: Name of threshold variable
\item threshold: Threshold value used
\item solve_time: Time to solve in seconds
\item mean_compactness: Mean Polsby-Popper compactness (if \code{compact = TRUE})
\item region_compactness: Per-region compactness scores (if \code{compact = TRUE})
}
}
\description{
Perform Max-P regionalization to maximize the number of spatially contiguous
regions such that each region satisfies a minimum threshold constraint on a
specified attribute. This is useful for creating regions that meet minimum
population or sample size requirements.
}
\details{
The Max-P algorithm (Duque, Anselin & Rey, 2012; Wei, Rey & Knaap, 2021)
solves the problem of aggregating n geographic areas into the maximum number
of homogeneous regions while ensuring:
\enumerate{
\item Each region is spatially contiguous (connected)
\item Each region satisfies a minimum threshold on a specified attribute
}

The algorithm has two phases:
\enumerate{
\item Construction phase: Builds feasible solutions via randomized greedy
region growing. Multiple random starts are explored in parallel.
\item Simulated annealing phase: Refines solutions by moving border areas
between regions to minimize within-region dissimilarity while respecting
constraints.
}

When \code{compact = TRUE}, the algorithm additionally optimizes for compact region
shapes based on Feng, Rey, & Wei (2022). Compact regions:
\itemize{
\item Minimize travel time within regions (useful for service territories)
\item Reduce gerrymandering potential (electoral districts)
\item Often result in finding MORE regions due to efficient space usage
}

\strong{Compactness metric}: This implementation uses a centroid dispersion
measure during optimization, rather than the Normalized Moment of Inertia (NMI)
described in Feng et al. (2022). This design choice provides two advantages:
\enumerate{
\item \strong{Point-based regionalization}: The algorithm works with both
polygon and point geometries. For point data, use KNN or distance-based
weights (e.g., \code{weights = list(type = "knn", k = 6)}).
\item \strong{Computational efficiency}: Centroid dispersion is O(n) per
region versus O(v) for NMI where v = total polygon vertices.
}
For polygon data, centroids are computed via \code{\link[sf:geos_unary]{sf::st_centroid()}}. Users should
be aware that centroid-based compactness may be less accurate for highly
irregular shapes or large, sparsely-populated areas where the centroid poorly
represents the polygon's spatial extent.

The reported \code{mean_compactness} and \code{region_compactness} in results use
Polsby-Popper (4\emph{pi}A/P^2), a standard geometric compactness measure for
polygons. For point data, these metrics are not computed.

This implementation is optimized for speed using:
\itemize{
\item Parallel construction with early termination
\item Efficient articulation point detection for move eligibility
\item Incremental threshold tracking
}
}
\examples{
\dontrun{
library(sf)
nc <- st_read(system.file("shape/nc.shp", package = "sf"))

# Create regions where each has at least 100,000 in BIR74
result <- max_p_regions(
  nc,
  attrs = c("SID74", "SID79"),
  threshold_var = "BIR74",
  threshold = 100000
)

# Check number of regions created
attr(result, "spopt")$n_regions

# With compactness optimization (for sales territories)
result_compact <- max_p_regions(
  nc,
  attrs = c("SID74", "SID79"),
  threshold_var = "BIR74",
  threshold = 100000,
  compact = TRUE,
  compact_weight = 0.5
)

# Check compactness
attr(result_compact, "spopt")$mean_compactness

# Plot results
plot(result[".region"])

# Point-based regionalization (e.g., store locations, sensor networks)
# Use KNN weights since points don't have polygon contiguity
points <- st_as_sf(data.frame(
  x = runif(200), y = runif(200),
  customers = rpois(200, 100),
  avg_income = rnorm(200, 50000, 15000)
), coords = c("x", "y"))

result_points <- max_p_regions(
  points,
  attrs = "avg_income",
  threshold_var = "customers",
  threshold = 500,
  weights = list(type = "knn", k = 6),
  compact = TRUE
)
}

}
\references{
Duque, J. C., Anselin, L., & Rey, S. J. (2012). The max-p-regions problem.
Journal of Regional Science, 52(3), 397-419.

Wei, R., Rey, S., & Knaap, E. (2021). Efficient regionalization for spatially
explicit neighborhood delineation. International Journal of Geographical
Information Science, 35(1), 135-151. \doi{10.1080/13658816.2020.1759806}

Feng, X., Rey, S., & Wei, R. (2022). The max-p-compact-regions problem.
Transactions in GIS, 26, 717-734. \doi{10.1111/tgis.12874}
}
